# Malware Data Science

## Table of Contents
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [Malware Data Science](#malware-data-science)
	- [Table of Contents](#table-of-contents)
	- [Chapter 1: Basic Static Malware Analysis](#chapter-1-basic-static-malware-analysis)
		- [PE Header](#pe-header)
		- [Optional Header](#optional-header)
		- [Section Headers](#section-headers)
		- [Dissecting a PE](#dissecting-a-pe)
		- [Examining Malware Images](#examining-malware-images)
	- [Chapter 2: Beyond Basic Static Analysis x86 Disassembly](#chapter-2-beyond-basic-static-analysis-x86-disassembly)
	- [Chapter 6: Understanding Machine Learning-Based Malware Detectors](#chapter-6-understanding-machine-learning-based-malware-detectors)
		- [Steps](#steps)
		- [Extracting Features](#extracting-features)
		- [Training](#training)

<!-- /TOC -->

__Bookmark: Page 20__ 

## Chapter 1: Basic Static Malware Analysis

### PE Header

Program Attributes

### Optional Header

* Entry Point
* Size of data loaded into memory
* Windows sub system
* Program Targets

### Section Headers

* `.text` - Code Section (marked executable)
* `.idata` - Imports
  - Import Address Table (IAT)
* Data Sections
  - `.rsrc` - Resources Section
    * Printable Character Strings
  - `.data`
  - `.reloc`

### Dissecting a PE

Based on Python `pefile` module.

  ```
  >>> import pefile
  >>> pe = pefile.PE("ircbot.exe")
  ```

Sections

  ```
  # based on Ero Carrera's example code (pefile library author)
  for section in pe.sections:
  print (section.Name, hex(section.VirtualAddress),
  hex(section.Misc_VirtualSize), section.SizeOfRawData )
  ```
* `Name` - Section Name
* `Virtual Address` - Base address Where sections will be loaded
* `Misc_VirtualSize` - Virtual Size of Section
* `SizeOfRawData` - Amount of data in memory chunk

List of loaded DLLs from dumping IAT

  ```
  pe = pefile.PE("ircbot.exe")
  for entry in pe.DIRECTORY_ENTRY_IMPORT:
  print entry.dll
  for function in entry.imports:
  print '\t',function.name
  ```

### Examining Malware Images

`fakepdfmalware.exe`
  * Chinese state-sponsored hacking group
  * Adobe Acrobat Document

Examine `.rsrc` section using `wrestool`.
  * `-x` - Extract
  * `-o` - Convert any resource sin Adobe `.ico` to `.png`

## Chapter 2: Beyond Basic Static Analysis x86 Disassembly

Use __`linear disassembly`__, which involves identifying the contiguous sequence of bytes in a PE.

Limitations:
  * Ignores subtleties about how instructions are decoded by the CPU during execution.
  * Doesn't account for various obfuscation methods

_Personal Note: This book does not account for tools such as IDA or Binja Headless. We can leverage that to get insane amounts of data at a performance cost._



## Chapter 6: Understanding Machine Learning-Based Malware Detectors

- logistic regression
- decision trees
- random forest

### Steps

1. Collect malicious and benign examples (Training Set)
2. Extract features to represent them as an array of numbers.
3. Train
4. Test

### Extracting Features

Some options include:

- Digitally Signed or not
- Malformed Headers
- Encrypted Data
- Seen on more than 100 network workstations

Caveats:

- Your feature set can become too large relative to the number of training examples for your detection system
  * 1000 features and only 100 training examples is a poor feature set. Loses to statistics
- Features need to represent a range of hypothesis that consitute benign or malicious files.
  * Encryption can be prominent but your system will leverage the other features to make a decision

### Training

- Supervised machine learning algorithms
  * Completed using known malicious and benign training sets.
- Unsupervised algorithms
  * Algorithms are much less effective at detecting malicious software and malicious behavior.
